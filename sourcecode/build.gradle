apply plugin: 'war'
// 'war' plugin will apply 'java' plugin automatically
apply plugin: 'java'
apply plugin: 'eclipse'
// run web application, refer to http://gradle.org/docs/current/userguide/jetty_plugin.html
apply plugin: 'jetty'
// The FindBugs plugin performs quality checks on your project's Java source files using FindBugs and generates reports from these checks.
//apply plugin: 'findbugs'
// The JaCoCo plugin provides code coverage metrics for Java code via integration with JaCoCo
apply plugin: 'jacoco'
// refer to official website https://github.com/bmuschko/gradle-tomcat-plugin
apply plugin: 'com.bmuschko.tomcat'

// define some golbal switching parameter
def KEY_connect_subversion = 'connectSubversion'
def KEY_jetty_daemon = 'jettyDaemon'
// set '-Dquiet=true' to disable console input.
def KEY_QUIET = 'quiet'

/**
 * Gradle includes 2 phases: configuration and execution, refer to 
 * http://stackoverflow.com/questions/11558824/gradle-tar-task-not-executed.
 * 
 * - CONFIGURATION PHASE
 * In configuration phase, all codes except doFirst() and doLast() will be executed from top to bottom of the script. 
 * The 'dependsOn' doesn't make any sense in configration phase, for example, the 'jar' and 'svnrev' tasks, if we put
 * 'svnrev' after 'jar', then variable 'svnrev.lastRev' can't be parsed at 'jar' task, as it completely hasn't been
 * initilized at all.
 * 
 * - EXECUTION PHASE
 * In execution phase, the dependency mechanism of task will work. Be reminded that only doFirst() and doLast() will be 
 * executed at execution phase, and gradle will finished configuration of whose script first to initialize and determine
 * what tasks should be executed and what is the execution order.
 */ 

//defaultTasks 'clean', 'javadoc','dist', 'svntag'
defaultTasks 'clean', 'javadoc', 'build', 'jacocoTestReport'

logger.quiet(">> Start building of $_name.$version.")

compileTestJava.options.encoding = _sourcecode_encoding
// Define a temporary variable.
//_tmp="define a temporary variable"
//logger.quiet(">> Define a temporary variable: _tmp: $_tmp")

//Properties added by the 'war' plugin
webAppDirName="src/main/WWW"

buildscript {
    repositories {
        jcenter()
    }

    dependencies {
        classpath 'com.bmuschko:gradle-tomcat-plugin:2.0'
    }
}

repositories {
    mavenCentral()
}

configurations {
    provided {
        description = 'Non-exported comiple-time dependencies, it will be provided by container.'
    }
    driver {
        description = 'jdbc driver libaries'
    }
}

/**
 * In Gradle dependencies are grouped into configurations, and there are 4 pre-defined configuration: 
 * compile, runtime, testCompile and testRuntime. In general dependencies of the later one will contain previous one.
 */
dependencies {
    // configurationName dependencyNotation1, dependencyNotation2, ...
    // compile group: 'commons-collections', name: 'commons-collections', version: '3.2'

    provided files('lib/DEV/j2ee/servlet-api.jar')
    compile fileTree(dir: 'lib', include: '**/*.jar', exclude: 'DEV/**/*.jar')
    /**
     * Below dependency will result in a exception:
     *      Circular dependency between tasks. Cycle includes [task ':compileJava', task ':classes']. 
     * As sourceSets.main.output is generated by task 'compileJava', however if we declare the dependency here, it means task 
     * 'compileJava' will depend on this file too, then a circular dependency occurs.
     */
    //compile sourceSets.main.output
    testCompile fileTree(dir:"lib", include:"DEV/**/*.jar")
    driver files('lib/oracle/ojdbc6.jar')

    //def tomcatVersion = '6.0.37'
    //tomcat "org.apache.tomcat:catalina:${tomcatVersion}",
    //       "org.apache.tomcat:coyote:${tomcatVersion}",
    //       "org.apache.tomcat:jasper:${tomcatVersion}"
    def tomcatVersion = '7.0.57'
    tomcat "org.apache.tomcat.embed:tomcat-embed-core:${tomcatVersion}",
           "org.apache.tomcat.embed:tomcat-embed-logging-juli:${tomcatVersion}"
    tomcat("org.apache.tomcat.embed:tomcat-embed-jasper:${tomcatVersion}") {
        exclude group: 'org.eclipse.jdt.core.compiler', module: 'ecj'
    }    
}

jacoco {
    toolVersion = "0.6.2.201302030002"
    //reportsDir = file("$buildDir/customJacocoReportDir")
}

// Configuring the JaCoCo Plugin, refer to http://forums.gradle.org/gradle/topics/_1_6_rc_1_jacoco_plugin_does_not_show_line_numbers
jacocoTestReport {
  group = "Reporting"
  description = "Generate Jacoco coverage reports after running tests."
  additionalSourceDirs = files(sourceSets.main.allJava.srcDirs)
}

/**
 * To load Oracle JDBC driver, refer to http://stackoverflow.com/questions/6329872/how-to-add-external-jar-files-to-gradle-build-script
 */
URLClassLoader loader = GroovyObject.class.classLoader
configurations.driver.each {File file ->
    loader.addURL(file.toURL())
}

sourceSets {
    /**
     * The Java plugin defines two standard source sets, called 'main' and 'test'. 
     * Changing the project layout, the default project layout is as below:
     *  - src/main/java   Production Java source
     *  - src/main/resources  Production resources
     *  - src/test/java   Test Java source
     *  - src/test/resources  Test resources
     *  - src/sourceSet/java  Java source for the given source set
     *  - src/sourceSet/resources Resources for the given source set
     * Refer to http://gradle.org/docs/current/userguide/java_plugin.html and 
     * http://gradle.org/docs/current/dsl/org.gradle.api.tasks.SourceSet.html for more information.
     */
    main {
        compileClasspath = compileClasspath + configurations.provided
        //compileClasspath.collect().each({println it})
        resources {
            srcDir 'src/main/resource'
        }
    }
    test {
        resources {
            srcDir 'src/test/resource'
        }
    }
}

// If no below statements, JPA/Hibernate will throw exception(no persistent classes found) when 
// run integration test, refer to http://stackoverflow.com/questions/14742941/no-persistent-classes-found-when-integration-test-in-gradle
sourceSets.main.output.resourcesDir = sourceSets.main.output.classesDir
sourceSets.test.output.resourcesDir = sourceSets.test.output.classesDir

import groovy.sql.Sql
task reloadDB << {
    def props = [user: _jdbc_user, password: _jdbc_password, allowMultiQueries: 'true'] as Properties
    //def props = [user: 'ramon', password: 'ramon', allowMultiQueries: 'true'] as Properties
    def url = "${_jdbc_url}"
    def driver = "${_jdbc_driver}"
    def sql = Sql.newInstance(url, props, driver)

    /**
     * can NOT add comment in a SQL statement, for example:
     * insert into ACCESS_RIGHT (ACCESS_ID, MODULE_ID) -- can't comment here, even ORACLE SQL Developer will recognize it.
     *      values ('T005', null);
     */ 
    def sqlfiles = ['etc/db/oracle_testdata.sql', 
                    'etc/db/oracle_testdata_luckydraw.sql', 
                    'etc/db/ig/oracle_testdata_ig.sql',
                    'etc/db/lotto/oracle_testdata_lotto.sql',
                    'etc/db/toto/oracle_testdata_toto.sql',
                    'etc/db/lfn/oracle_testdata_l590.sql',
                    'etc/db/raffle/oracle_testdata_raffle.sql',
                    'etc/db/magic100/oracle_testdata_magic100.sql',
                    'etc/db/digital/oracle_testdata_digital.sql',
                    'etc/db/union/oracle_testdata_union.sql',
                    'etc/db/bingo/oracle_testdata_bingo.sql',
                    'etc/db/vas-vat/oracle_testdata_vat.sql',
                    'etc/db/vas-airtime/oracle_testdata_airtime.sql',
                    'etc/db/vas-voucher/oracle_testdata_voucher.sql',
		    'etc/db/transfer/oracle_transfer.sql',
                   ]
    sqlfiles.each {sqlfile ->
        logger.quiet "Load sql file: " + sqlfile
        def sqlline = ""
        new File(sqlfile).readLines().findAll({!it.trim().equalsIgnoreCase("") && !it.trim().startsWith("--") && !it.trim().startsWith("/*")}).each { line ->
            sqlline += line.trim()
            if (sqlline.endsWith(";")) {
                // remove the ";" from tail
                sqlline = sqlline[0..sqlline.size()-2]
                // perform sqlline as  SQL statement
                //logger.quiet("[Execute SQL]" + sqlline)
                sql.execute(sqlline)

                // reset sqlline for next sql statement
                sqlline = ""
            }
        }
    }
}

compileJava {
    options.encoding = _sourcecode_encoding
    // Properties added by the 'java' plugin
    sourceCompatibility="${_source_compatibility}"
    targetCompatibility="${_target_compatibility}"
}

test {
    scanForTestClasses  = false
    classpath = configurations.provided + configurations.compile + configurations.testCompile + sourceSets.main.output + sourceSets.test.output
    // customize test process
    //include 'com/mpos/lottery/te/**/UnionTestSuite.class'
    include 'com/mpos/lottery/te/**/*TestSuite.class'
    include 'com/mpos/lottery/te/**/*UnitTest.class'
    exclude 'com/mpos/lottery/te/test/**/Base*Test.class'
}
test.dependsOn 'thirdpartyRun', 'reloadDB'

// Retrieve the last revision of project, refer to http://stackoverflow.com/questions/9044354/checkout-svn-using-gradle.
def _svn_user,_svn_password 
def svnkey_file = '.svnkey'
// lookup svn user/password
File svnProp = new File(svnkey_file)
if (!svnProp.exists()) {
    if (svnProp.createNewFile()) {
        logger.quiet """
        No file $svnkey_file found, a default one has been created. Below 2 entries must be set:
          _svn_user     - the user name of Subversion account.
          _svn_password - The password of Subversion account.
        And do NOT committ this file into subversion repository.
        """
    }
    System.exit(1)
}else {
    Properties props = new Properties()
    props.load(new FileInputStream(svnProp))
    _svn_user = props.getProperty("_svn_user")
    _svn_password = props.getProperty("_svn_password")
}
task svnrev {
    description = "Retrieve the head revision number from subversion repository."

    if (System.getProperty(KEY_connect_subversion) != null && System.getProperty(KEY_connect_subversion).equalsIgnoreCase('false')){
        logger.quiet("No need to get revision number from subverion repository.")
        ext.lastRev = ''
    }
    else {
        // use ant to retrieve revision.
        ant.taskdef(resource: 'org/tigris/subversion/svnant/svnantlib.xml') {
            classpath {
                fileset(dir: 'lib/DEV/svnant-1.2.1', includes: '*.jar')
            }
        }
        ant.svn(javahl: 'false', svnkit: 'true', username: "${_svn_user}", password: "${_svn_password}", failonerror: 'false') {
            ant.info(target: "${_svn_source_url}", propPrefix: 'svninfo')
        }
        // retrieve property of ant project and assign it to a task's property, refer to:
        // http://gradle.1045684.n5.nabble.com/can-t-find-or-extract-properties-from-svnant-info-function-in-gradle-td3335388.html
        ext.lastRev = ant.getProject().properties['svninfo.lastRev']
        // retrieve property of gradle project
        //getProject().properties['buildFile']
    }    
}

javadoc {
    classpath = configurations.provided + configurations.compile + configurations.testCompile + sourceSets.main.output + sourceSets.test.output
    // encoding is used to set the sourccode encoding, while how to set doc??
    options.encoding = _sourcecode_encoding
    excludes = ["com/mpos/game/eig/**","com/mpos/game/fd/**","com/mpos/game/bingo/**","com/mpos/game/raffle/**",
        "com/mpos/game/toto/**", "com/mpos/lottery/te/instantgame/**"]

    doLast {
        // make sure the images will be copied to destination folder of javadoc
        copy {
            from "src/main/java"
            into "$buildDir/docs/javadoc"
            include '**/*.png' 
            include '**/*.jpg'
        }
    }
}

import org.gradle.api.java.archives.internal.DefaultManifest
import org.gradle.api.internal.file.IdentityFileResolver
task generateManifest {
    // define a task's property
    ext.m = new DefaultManifest(new IdentityFileResolver())

    // add some attributes
    m.attributes([
        'Implementation-Title':"$_name",
        'Implementation-Version':"${version}_${svnrev.lastRev}", 
        'Implementation-Vendor':"$_company", 
        'Created-By' : _team,
        'Build-By'   : "Gradle ${gradle.gradleVersion}",
        'Build-Time' : new Date()
    ]) 
    //manifest.writeTo('build/mymanifest.mf')
}
war.dependsOn 'generateManifest'

war {
    archiveName = _name + ".war"
    manifest = generateManifest.m
}

// Launch a remote MOCK service for testing, for example a player account service.
task ('thirdpartyRun', type: org.gradle.api.plugins.jetty.JettyRun) {
    description = "Startup a thirdpart system for integration test, give '-D${KEY_jetty_daemon}=false' to make jetty run at foreground."

    // Specifies whether the Jetty server should run in the background. When true, this task completes as soon as the server 
    // has started. When false, this task blocks until the Jetty server is stopped.
    daemon = !("false".equalsIgnoreCase(System.getProperty(KEY_jetty_daemon)))

    classpath = test.classpath
    httpPort = 9090
    webXml = new File("src/test/www/WEB-INF/web.xml")
    contextPath = "3rdparty"
    webAppSourceDirectory = new File("src/test/www")
}
thirdpartyRun.dependsOn 'testClasses'

// Launch TE for testing, as spring test-context framework has its disadvantages:
//  - negative postive (may create/update/delete sql won't hit underlying database at all)
//  - Jpa proxy entity. As the test method of spring test-context framework is in 
//  transaction, xml serialization works well. However in real environment, xml serialization 
//  is performed out of transaction, in this case, proxy entity will cause exception.
// 
// Enable remote debug
//  - On windows OS
//    set JAVA_OPTS=%JAVA_OPTS% -Xdebug -Xrunjdwp:transport=dt_socket,address=9999,server=y,suspend=n
task ('teRun', type:com.bmuschko.gradle.tomcat.tasks.TomcatRun) {
    httpPort = 8090
    httpsPort = 8091
    //webDefaultXml = new File("src/main/www/WEB-INF/web.xml")
    contextPath = "mlottery_te"
    webAppSourceDirectory = new File("src/main/www")
}

// Define a global variable
def user_tag, commit_msg

task svntag {
    // description can only be parsed in configuration phase.
    description = "Make a tag at subversion repository, you can specify'-D${KEY_connect_subversion}=false' to disable this feature, also '-Dquiet=true' to disable console input."

    doLast{
        if (System.getProperty(KEY_connect_subversion) != null && System.getProperty(KEY_connect_subversion).equalsIgnoreCase('false')){
            logger.quiet("No tag will be created, this feature has been disabled.")
        }
        else {
            def console = System.console()
            if (System.getProperty(KEY_QUIET) != null && System.getProperty(KEY_QUIET).equalsIgnoreCase('true')){
                user_tag = version
            } else {
                // if run gradle in deamon mode, System.getConsole() will return null.
                if (console) {
                    // get version number
                    user_tag = console.readLine("> Please enter your tag(press enter for ${version}): ")
                    // get commit message
                    commit_msg = console.readLine("> What is commit message? ")
                } 
                else {
                    logger.quiet("No System.console found.")
                }
                if (!user_tag) {
                    user_tag = version
                }
                logger.quiet ">>Use version: ${version}"
               if (!commit_msg) {
                    commit_msg = "Create tag $user_tag"
                }
                logger.quiet ">>Commit message: ${commit_msg}"
            }

            ext.svn_target = "${_svn_tag_url}/${user_tag}"
            ant.svn(javahl: 'false', svnkit: 'true', username: "${_svn_user}", password: "${_svn_password}", failonerror: 'false') {
                ant.info(target: "${svn_target}", propPrefix: 'taginfo')
            }
            // retrieve property of ant project and assign it to a task's property, refer to:
            // http://gradle.1045684.n5.nabble.com/can-t-find-or-extract-properties-from-svnant-info-function-in-gradle-td3335388.html
            ext.tagrev = ant.getProject().properties['taginfo.lastRev']
            // if no tag(or url) found, the 'tagrev' will be null.
            if (ext.tagrev != null) {
                  // once a tag has been created, can't apply any change on it...it is the rule.
                  logger.error "ERROR: Tag[${user_tag}] is alredy existed, choose another tag."
                  System.exit(1)
            } 
            else 
                println ">Will create new tag: ${user_tag} at ${svn_target}"   

            // create tag
            ant.svn(javahl: 'false', svnkit: 'true', username: "${_svn_user}", password: "${_svn_password}", failonerror: 'false') {
                ant.copy(srcurl: "${_svn_source_url}", desturl:"${svn_target}", message:"Create tag $user_tag(${commit_msg})")
            }
            println ">Create tag(${user_tag}) successfully."
        }
    }
}

// TODO refactor to disable 'loadDB' task when run 'dist' task
task dist(type: Zip) {
    description = "Build a distribution package containing war and shell script."

    archiveName = _name + "_SE" + "_v${version}.zip"

    // if use include, gradle will inform 'Skipping task ':zip' as it has no source files'...why?
    // include 'config'    

    from('.') {
        include 'README.txt'
        include 'CHANGELOG.txt'
    }
    from war.destinationDir  
    into('bin') {
        from('bin'){
            include 'app_backup.sh'
            include 'gen-keypair.sh'
            include 'gen-keypair.bat'
            include 'gen-serialkey.sh'
            include 'te_upgrade.sh'
        }
    }
    from 'etc/manual'
    into('javadoc'){
        from javadoc.destinationDir
    }
    into('reports'){
        //from test.getReports().getHtml().getDestination()
        from "$buildDir/reports"
    }    

    doLast {
        //print 'source of zip:' + project['zip'].source.each({println it})
    }
}
dist.dependsOn 'svntag'

